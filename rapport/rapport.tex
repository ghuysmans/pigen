\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[margin=1.5cm]{geometry}
\author{Guillaume \textsc{Huysmans}, Martin \textsc{Lempereur}}
\title{Génération de nombres à partir des décimales de $\pi$}
\begin{document}
\maketitle

\section{Introduction}
Le CPU d'un ordinateur est entièrement déterministe. Certains algorithmes
utilisés par exemple en intelligence artificielle ne le sont pas et auront de
bien meilleurs résultats lorsqu'ils pourront explorer <<~au hasard~>> différentes
zones de leur espace de recherche. Différentes méthodes existent afin de générer
des nombres pseudo-aléatoires (ils ne le sont pas vraiment puisqu'ils sont
implémentés avec des algorithmes parfaitement déterministes). La seule donnée
peu prévisible que nous choisissons d'utiliser est le moment auquel le générateur
est lancé.
Les méthodes vues au cours afin de générer des nombres selon des lois normales,
poissonniennes, exponentielles, etc. se basent sur un générateur uniforme et
c'est ce que nous essaierons de construire ici. 

\section{Tests}
L'erreur de première espèce (risque de confirmer à tort l'hypothèse de même loi)
est fixée à $\alpha=0.05$, soit 5\%.

\subsection{Histogramme}
Un histogramme peut nous donner un premier aperçu sur la répartition
du premier million de décimales du nombre $\pi$.
Cependant un histogramme n'a aucune valeur scientifique \textit{per se}. 
On peut facilement comprendre que la séquence [0,1,2,3,4,5,6,7,8,9]
nous donnera un histogramme parfaitement régulier alors qu'elle est déjà loin
de la définition intuitive que l'on peut avoir du hasard.
Nous avons donc implémenté une batterie de tests qui se concentrent sur d'autres aspects de l'uniformité.

\subsection{Test du Gap}
On décide d'un intervalle $[a,b] \subset [0,1]$,
on génère une séquence de nombres réels en regroupant les décimales par 5
et on marque ceux compris dans cet intervalle. Le but du test est de regarder les
distances entre deux nombres marqués successifs.

Soit $r$ la longueur d'un gap,
les valeurs attendues en fonction de $r$ sont les suivantes :
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c}
$0$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ & $9$ & $\geq 10$ \\ \hline
50000 & 25000 & 12500 & 6250 & 3125 & 1562.5 & 781.25 & 390.625 &
	195.3125 & 97.65625 & 97.65625
\end{tabular}
\end{center}

\texttt{./gap.py 10 200000 1 <pi6.txt} donne :
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c}
$0$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ & $9$ & $\geq 10$ &
	$\chi^2$ & Probabilité \\ \hline
49857 & 24928 & 12627 & 6271 & 3128 & 1569 & 750 & 381 & 234 & 83 & 85 &
	15 &  0.13
\end{tabular}
\end{center}

Avec des chiffres générés avec le module \texttt{random} de Python,
cela fonctionne également :
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c}
$0$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ & $9$ & $\geq 10$ &
	$\chi^2$ & Probabilité \\ \hline
49680 & 25022 & 12509 & 6279 & 3138 & 1578 & 765 & 377 & 201 & 109 & 102 &
	4.91 &  0.90
\end{tabular}
\end{center}


\subsection{Test du Poker}
En utilisant les 10 chiffres dans les décimales fournies et avec une main de 10,
on se retrouve avec au moins une classe vide : celle du poker. En effet, la
probabilité d'obtenir une main avec 10 chiffres identiques est de $10^{-9}$
(le premier chiffre peut être n'importe lequel mais il n'y a ensuite plus
qu'une possibilité à chaque fois). Avec $10^6/10=10^5$ mains, on obtient en
moyenne $10^{-4}=0,0001$ occurrence, ce qui n'arrivera jamais en pratique.
Pour pallier à ce problème, on regroupe à l'entrée les chiffres : 0 avec 1,
2 avec 3, etc. Cela semble raisonnable puisque les chiffres sont répartis
de manière uniforme. Ainsi, nous utiliserons 5~classes qui correspondront
à chaque fois au nombre de chiffres différents obtenus après $k=5$ tirages.
On prend $n$ mains pour un test. Afin d'utiliser tout le fichier de données,
nous choisissons $n=200000$ puisque $n$ mains de $k$ chiffres font 1 million.

On va comparer les résultats de nos tests aux valeurs théoriques suivantes :
\begin{center}
\begin{tabular}{l|l|l|l|l}
1 seule & 2 $\neq$ & 3 $\neq$ & 4 $\neq$ & 5 $\neq$ \\ \hline
320 & 19200 & 96000 & 76800 & 7680
\end{tabular}
\end{center}

\texttt{./poker.py 5 5 200000 <pi6.txt} produit les résultats suivants :
\begin{center}
\begin{tabular}{l|l|l|l|l|c|c}
1 seule & 2 $\neq$ & 3 $\neq$ & 4 $\neq$ & 5 $\neq$
	& $\chi^2$ & Probabilité \\ \hline
337 & 19242 & 95873 & 77043 & 7505 &  5.92 &  0.21
\end{tabular}
\end{center}

Pour donner un point de comparaison avec le générateur inclus à Python,
nous avons
exécuté ce même test sur des nombres générés à partir du module \texttt{random}.

\begin{center}
\begin{tabular}{l|l|l|l|l|c|c}
1 seule & 2 $\neq$ & 3 $\neq$ & 4 $\neq$ & 5 $\neq$
	& $\chi^2$ & Probabilité \\ \hline
343 & 19175 & 95521 & 77274 & 7687 &  7.01 &  0.14
\end{tabular}
\end{center}


\subsection{Test du collectionneur de coupons}
On essaie de collectionner $s$ coupons (par défaut 10 -- un par chiffre)
jusqu'à maximum $m$ tirages.
On crée une classe par nombre de tirages nécessaires pour les collectionner tous.
Il n'y en aura jamais pour moins de $s$ lancers puisqu'on veut obtenir
$s$ coupons différents.
Une dernière classe regroupe les longueurs strictement supérieures à $m$.
Le test est répété $t$ fois sur des séquences consécutives dans le fichier.

Soit $l$ le nombre de lancers, les résultats théoriques attendus
sont les suivants :

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
$l = 10$ & $l = 11$ & $l = 12$ & $l = 13$ & $l = 14$ & $l \geq 15$ \\ \hline
0.36288 & 1.63296 & 4.191264 & 8.083152 & 13.045608576 & 972.684135424\\ \hline

\end{tabular}
\end{center}

\newpage
\texttt{./coupon.py 1000 15 1000 <pi6.txt} fonctionne à 95\%.

On compare les résultat théoriques ci-dessus aux résultats des tests suivants :

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
$l = 10$ & $l = 11$ & $l = 12$ & $l = 13$ & $l = 14$ & $l \geq 15$ & $\chi^2$ & Probabilité \\ \hline
2 & 2 & 6 & 10 & 12 & 968 &  8.81 &  0.12\\ \hline
0 & 3 & 4 & 8 & 14 & 971 &  1.59 &  0.90\\ \hline
0 & 1 & 4 & 6 & 8 & 981 &  3.18 &  0.67\\ \hline
0 & 2 & 9 & 6 & 10 & 973 &  7.21 &  0.21\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
0 & 1 & 3 & 8 & 10 & 978 &  1.69 &  0.89\\ \hline
0 & 2 & 1 & 8 & 16 & 973 &  3.55 &  0.62\\ \hline
1 & 1 & 8 & 12 & 12 & 966 &  6.85 &  0.23\\ \hline
0 & 2 & 3 & 10 & 10 & 975 &  1.96 &  0.86\\ \hline
0 & 0 & 7 & 7 & 4 & 982 & 10.38 &  0.07\\ \hline
1 & 2 & 2 & 10 & 13 & 972 &  2.80 &  0.73\\ \hline
0 & 2 & 4 & 5 & 12 & 977 &  1.73 &  0.88\\ \hline
1 & 2 & 2 & 8 & 11 & 976 &  2.68 &  0.75\\ \hline
0 & 1 & 4 & 6 & 13 & 976 &  1.17 &  0.95\\ \hline
0 & 0 & 6 & 5 & 10 & 979 &  4.70 &  0.45\\ \hline
0 & 1 & 2 & 9 & 14 & 974 &  1.93 &  0.86\\ \hline
1 & 5 & 2 & 11 & 14 & 967 & 10.36 &  0.07\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
1 & 0 & 7 & 9 & 14 & 969 &  4.82 &  0.44\\ \hline
0 & 1 & 2 & 8 & 18 & 971 &  3.64 &  0.60\\ \hline
1 & 1 & 2 & 6 & 18 & 972 &  4.93 &  0.42\\ \hline
1 & 0 & 5 & 9 & 11 & 974 &  3.33 &  0.65\\ \hline
\end{tabular}
\end{center}

\newpage
Les mêmes tests réalisés sur les nombres générés par \texttt{random}
nous donnent ceci :


\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
$l = 10$ & $l = 11$ & $l = 12$ & $l = 13$ & $l = 14$ & $l \geq 15$ & $\chi^2$ & Probabilité \\ \hline
0 & 1 & 4 & 6 & 11 & 978 &  1.50 &  0.91\\ \hline
0 & 3 & 1 & 7 & 14 & 975 &  4.16 &  0.53\\ \hline
1 & 1 & 3 & 6 & 13 & 976 &  2.25 &  0.81\\ \hline
0 & 2 & 1 & 5 & 6 & 986 &  8.04 &  0.15\\ \hline
1 & 0 & 1 & 7 & 11 & 980 &  5.70 &  0.34\\ \hline
0 & 0 & 2 & 7 & 6 & 985 &  7.25 &  0.20\\ \hline
1 & 2 & 6 & 7 & 11 & 973 &  2.45 &  0.78\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline

1 & 1 & 6 & 9 & 20 & 963 &  6.05 &  0.30\\ \hline
0 & 1 & 6 & 7 & 12 & 974 &  1.62 &  0.90\\ \hline
0 & 4 & 5 & 5 & 8 & 978 &  7.11 &  0.21\\ \hline
0 & 2 & 6 & 5 & 17 & 970 &  3.61 &  0.61\\ \hline
1 & 0 & 9 & 10 & 14 & 966 &  8.84 &  0.12\\ \hline
0 & 1 & 5 & 11 & 8 & 975 &  3.77 &  0.58\\ \hline
0 & 1 & 6 & 13 & 22 & 958 & 10.75 &  0.06\\ \hline
0 & 1 & 3 & 8 & 9 & 979 &  2.24 &  0.81\\ \hline
1 & 2 & 8 & 7 & 12 & 970 &  4.90 &  0.43\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
0 & 1 & 2 & 10 & 12 & 975 &  2.30 &  0.81\\ \hline
0 & 2 & 2 & 9 & 17 & 970 &  2.90 &  0.72\\ \hline
0 & 2 & 4 & 12 & 8 & 974 &  4.31 &  0.51\\ \hline
0 & 2 & 7 & 11 & 13 & 967 &  3.41 &  0.64\\ \hline
1 & 0 & 1 & 10 & 10 & 978 &  6.38 &  0.27\\ \hline
0 & 2 & 2 & 8 & 12 & 976 &  1.69 &  0.89\\ \hline
0 & 4 & 6 & 10 & 18 & 962 &  7.03 &  0.22\\ \hline
0 & 2 & 1 & 7 & 6 & 984 &  6.96 &  0.22\\ \hline
0 & 3 & 7 & 8 & 13 & 969 &  3.40 &  0.64\\ \hline
\end{tabular}
\end{center}

On donc ici un taux de réussite de $98\%$
\section{Générateur}
Puisque les décimales de $\pi$ semblent proches d'une séquence de chiffres
pseudo-aléatoire, nous pouvons les utiliser afin d'obtenir un \textit{seed}
pour un LCG\footnote{Linear Congruential Generator}. Ce dernier ne sera utilisé
que $k=100$ fois avant d'utiliser la séquence suivante. Celle-ci est composée de
$d=10$ chiffres qui forment ensemble un (grand) nombre entier.
Le multiplicateur du générateur est un nombre premier de 10 chiffres testé
à l'aide de l'outil \texttt{factor} issu des \textit{GNU coreutils}.
L'incrément a été fixé à 42 de façon totalement arbitraire.
Le module vaut $2^{20}$, ce qui permet de calculer rapidement par masquage
le reste de la division.
Les chiffres générés sont uniquement le premier dans les décimales de chaque
valeur de départ divisée par $m$.
Puisque le numérateur est par définition toujours strictement inférieur à $m$,
c'est un rationnel dans $]0,1[$ qui est utilisé.

La position de départ dans le fichier contenant le million de décimales
est déterminée par la date en secondes. Lorsqu'on arrive au bout de ce fichier,
on recommence depuis le début.

Les résultats des tests sur les chiffres générés avec les mêmes paramètres
qu'à la section précédente se trouvent à la figure \ref{fig:genD}.

\begin{figure}
\center
%FIXME
\begin{tabular}{l|c|c|c}
Test & $\pi$ & Générés & Résultat \\ \hline \hline
Poker & 91\% & 98\% & > \\ \hline
Gap & 85\% & 85\% & = \\ \hline
Coupons & 95\% & 94\% & <
\end{tabular}
\caption{Comparaison des chiffres générés et des premières décimales de $\pi$}
\label{fig:genD}
\end{figure}

\subsection{Tests}
%FIXME
Nous allons réitérer les mêmes tests que nous avons réalisés sur les décimales
de $\pi$ et sur des chiffres générés par le module \texttt{random} de Python
mais cette fois-ci sur des nombres générés à l'aide de notre générateur.
Pour reproduire ces tests, il suffit de reprendre les commandes qui ont été utilisées dans les sections précédentes.

\textbf{Rappel :} Les paramètres restant inchangés, on compare
les résultats générés aux valeurs théoriques citées précédemment.
\subsubsection{Poker}

\begin{center}
\begin{tabular}{l|l|l|l|l|c|c}
1 seule & 2 $\neq$ & 3 $\neq$ & 4 $\neq$ & 5 $\neq$
	& $\chi^2$ & Probabilité \\ \hline
325 & 19186 & 96388 & 76583 & 7518 &  5.69 &  0.22
\end{tabular}
\end{center}

\subsubsection{Gap}

Les résultats obtenus en réalisant plusieurs tests du Gap sur des nombres issus
de notre générateur sont les suivants :

\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c}
$0$ & $1$ & $2$ & $3$ & $4$ & $5$ & $6$ & $7$ & $8$ & $9$ & $\geq 10$ &
	$\chi^2$ & Probabilité \\ \hline
50191 & 25010 & 12601 & 6322 & 3159 & 1530 & 730 & 398 & 168 & 91 & 86 &
	12.59 &  0.25
\end{tabular}
\end{center}

\subsection{Coupons}

Nous terminons par la réalisation de plusieurs autres tests de coupons mais
cette fois-ci sur les nombres obtenus avec notre générateur.

On obtient un taux de réussite de $94\%$ sur les résultats suivants :

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|}
\hline
$l = 10$ & $l = 11$ & $l = 12$ & $l = 13$ & $l = 14$ & $l \geq 15$ & $\chi^2$ & Probabilité \\ \hline
1 & 1 & 7 & 8 & 14 & 969 &  3.33 &  0.65\\ \hline
1 & 4 & 4 & 5 & 8 & 978 &  7.71 &  0.17\\ \hline
0 & 0 & 2 & 11 & 22 & 965 & 10.40 &  0.06\\ \hline
0 & 2 & 0 & 8 & 23 & 967 & 12.27 &  0.03\\ \hline
0 & 1 & 5 & 7 & 5 & 982 &  5.96 &  0.31\\ \hline
0 & 3 & 4 & 8 & 14 & 971 &  1.59 &  0.90\\ \hline
1 & 0 & 8 & 4 & 13 & 974 &  8.28 &  0.14\\ \hline
0 & 0 & 7 & 6 & 11 & 976 &  4.75 &  0.45\\ \hline
0 & 2 & 5 & 6 & 13 & 974 &  1.14 &  0.95\\ \hline
0 & 3 & 2 & 10 & 8 & 977 &  5.08 &  0.41\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
1 & 1 & 7 & 7 & 6 & 978 &  7.23 &  0.20\\ \hline
0 & 3 & 1 & 11 & 14 & 971 &  5.06 &  0.41\\ \hline
0 & 2 & 2 & 9 & 12 & 975 &  1.78 &  0.88\\ \hline
0 & 2 & 6 & 12 & 13 & 967 &  3.16 &  0.68\\ \hline
0 & 1 & 5 & 8 & 21 & 965 &  5.68 &  0.34\\ \hline
0 & 1 & 2 & 9 & 13 & 975 &  1.86 &  0.87\\ \hline
0 & 0 & 6 & 13 & 19 & 962 &  8.60 &  0.13\\ \hline
0 & 1 & 3 & 9 & 12 & 975 &  1.14 &  0.95\\ \hline
0 & 1 & 5 & 5 & 14 & 975 &  2.02 &  0.85\\ \hline
0 & 2 & 4 & 10 & 7 & 977 &  3.73 &  0.59\\ \hline
0 & 0 & 3 & 13 & 18 & 966 &  7.25 &  0.20\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
 . & . & . & . & . & . & . & .\\ \hline
0 & 1 & 3 & 13 & 7 & 976 &  6.75 &  0.24\\ \hline
0 & 3 & 4 & 6 & 13 & 974 &  2.05 &  0.84\\ \hline
1 & 1 & 1 & 2 & 13 & 982 &  8.46 &  0.13\\ \hline
0 & 1 & 6 & 10 & 9 & 974 &  3.10 &  0.68\\ \hline
1 & 0 & 3 & 6 & 11 & 979 &  3.99 &  0.55\\ \hline
2 & 1 & 4 & 7 & 14 & 972 &  7.86 &  0.16\\ \hline
0 & 4 & 4 & 6 & 4 & 982 & 10.70 &  0.06\\ \hline
\end{tabular}
\end{center}


\section{Conclusion}
Les résultats sont tout à fait corrects et notre générateur semble faire
au moins aussi bien que celui de Python pour la génération de séries de nombres
pseudo-aléatoires uniformes.

\end{document}
